(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{113:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return u}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var b=i.a.createContext({}),c=function(e){var t=i.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return i.a.createElement(b.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,b=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=a,u=p["".concat(o,".").concat(m)]||p[m]||d[m]||r;return n?i.a.createElement(u,s(s({ref:t},b),{},{components:n})):i.a.createElement(u,s({ref:t},b))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var b=2;b<r;b++)o[b]=n[b];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},82:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return c}));var a=n(3),i=n(7),r=(n(0),n(113)),o={id:"btrfs_diff",title:"btrfs_diff/"},s={unversionedId:"contributing/todos/btrfs_diff",id:"contributing/todos/btrfs_diff",isDocsHomePage:!1,title:"btrfs_diff/",description:"Improvements to the present codebase / tech debt",source:"@site/docs/contributing/todos/btrfs_diff.md",slug:"/contributing/todos/btrfs_diff",permalink:"/antlir/docs/contributing/todos/btrfs_diff",editUrl:"https://github.com/facebookincubator/antlir/edit/master/website/docs/contributing/todos/btrfs_diff.md",version:"current",sidebar:"docs",previous:{title:"Python",permalink:"/antlir/docs/contributing/coding-conventions/python"},next:{title:"compiler/",permalink:"/antlir/docs/contributing/todos/compiler"}},l=[{value:"Improvements to the present codebase / tech debt",id:"improvements-to-the-present-codebase--tech-debt",children:[]},{value:"Ideas for the future",id:"ideas-for-the-future",children:[]}],b={toc:l};function c(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"improvements-to-the-present-codebase--tech-debt"},"Improvements to the present codebase / tech debt"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"The current way of handling of clone references in our filesystem output\n(",Object(r.b)("inlineCode",{parentName:"p"},"ChunkClone"),"s) is deeply problematic because it is quadratic in the\nnumber of times an extent is cloned.  So, the representation becomes\nunusable as the number of represented snapshots grows.  The rationale for\nthis quadratic hack is discussed in ",Object(r.b)("inlineCode",{parentName:"p"},"extents_to_chunks.py"),".  However,\nunderneath the hood, all the clones share a single Extent object, which\nmeans we ",Object(r.b)("strong",{parentName:"p"},"could"),' treat this in a way that\'s linear in the number of\nclones.  The likely best approach would be akin to what we already do for\nhardlinks.  For chunks, we\'d introduce some kind of artificial "block" or\n"extent" numbering and deterministically populate it at serialization\ntime, as well as for user input.  Refer to ',Object(r.b)("inlineCode",{parentName:"p"},"serialize_subvol")," and\n",Object(r.b)("inlineCode",{parentName:"p"},"serialized_subvol_add_fake_inode_ids")," for the hardlink example.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"It is problematic that we have frozen & unfrozen versions of everything,\nwith subtle distinctions in semantics besides read-only vs read-write.\nFor example, it is silly that I need to ",Object(r.b)("inlineCode",{parentName:"p"},"freeze")," to\n",Object(r.b)("inlineCode",{parentName:"p"},"assert_valid_and_complete"),".  We have this wart for two reasons:"),Object(r.b)("ol",{parentName:"li"},Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"cloned-extent-finding is not an online algorithm, so we have to run\n",Object(r.b)("inlineCode",{parentName:"p"},"extents_to_chunks")," whenever we want to see what clones what.  Of\ncourse, the moment we make this index, we'd better make sure the\nrest of the structure is frozen, so that mutations don't invalidate\nthe index.  It may well be worth making the \"what clones what?\"\nindex update on each mutation, if it can be done in a way that is\nsimple and not grossly inefficient.  In a world like this, we\nno longer need ",Object(r.b)("inlineCode",{parentName:"p"},"freeze")," support -- ",Object(r.b)("inlineCode",{parentName:"p"},"deepcopy")," support is enough.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"We cannot easily share representation (and thus mehtods like\n",Object(r.b)("inlineCode",{parentName:"p"},"assert_valid_and_complete")," between the mutable and immutable\nversions of the data.  Finishing to build out ",Object(r.b)("inlineCode",{parentName:"p"},"deepfrozen")," is a\npath towards fixing that.  If done correctly, the mutable &\nimmutable data structures would become interchangeable for all\nread-only operations. This would make it much less important\nto fix (i).")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Instead of ",Object(r.b)("inlineCode",{parentName:"p"},"repr")," printing the device ID, print ",Object(r.b)("inlineCode",{parentName:"p"},"major,minor"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"It'd be good to rename ",Object(r.b)("inlineCode",{parentName:"p"},"Extent")," to something more descriptive, like\n",Object(r.b)("inlineCode",{parentName:"p"},"ExtentsLog")," (name to-be-improved), and to rename our current ",Object(r.b)("inlineCode",{parentName:"p"},"Chunk")," to\nbe ",Object(r.b)("inlineCode",{parentName:"p"},"Extent"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"The current implementation of ",Object(r.b)("inlineCode",{parentName:"p"},"InodeIDMap")," feels more complex (and\ninefficient) than it must be.  Streamline it once that's needed.  Concrete\npoints:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"get_children")," should maybe just return names, not full paths?"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Consistently use ",Object(r.b)("inlineCode",{parentName:"p"},"sendstream")," in filenames instead of ",Object(r.b)("inlineCode",{parentName:"p"},"send_stream"),".\nRationale: ",Object(r.b)("inlineCode",{parentName:"p"},"send-stream")," is a compound noun, the underscore makes it\nconfusable with ",Object(r.b)("inlineCode",{parentName:"p"},"send stream"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Consider renaming the ",Object(r.b)("inlineCode",{parentName:"p"},"dest")," field of ",Object(r.b)("inlineCode",{parentName:"p"},"link")," to be ",Object(r.b)("inlineCode",{parentName:"p"},"to"),".  This conflicts\nwith ",Object(r.b)("inlineCode",{parentName:"p"},"btrfs receive --dump")," nomenclature, but agrees with ",Object(r.b)("inlineCode",{parentName:"p"},"btrfs-progs"),"\nin-code field names.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Add an explicit test & TARGET for ",Object(r.b)("inlineCode",{parentName:"p"},"TraversalIDMaker"),"?")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"SubvolumeSet.render")," and ",Object(r.b)("inlineCode",{parentName:"p"},"get_by_rendered_id")," reaching into\n",Object(r.b)("inlineCode",{parentName:"p"},"_InnerInodeIDMap")," is pretty gross.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"SubvolumeSet")," claims it's ",Object(r.b)("inlineCode",{parentName:"p"},"deepcopy"),"able, but there is no direct test.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"inode_utils.py")," should have a small, simple, explicit test instead of\nbeing covered by the integration test.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'Our send-stream ingestion should handle multiple concatenated sendstreams,\nsince btrfs has an "end" command.  This makes many use-cases easier and\nmore UNIXy, e.g.  ',Object(r.b)("inlineCode",{parentName:"p"},"sendstreams_to_json_subvolumes.py"),".  Ensure that any\nuser of the ingestion APIs is ready to handle multiple send- streams.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Add a sendstream binary writer, confirm that parse-serialize produces\nbit-identical output (thus ensuring we lose nothing)."))),Object(r.b)("h2",{id:"ideas-for-the-future"},"Ideas for the future"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"While this toolchain already incidentally tests many aspects of the kernel\n& ",Object(r.b)("inlineCode",{parentName:"p"},"btrfs-progs"),' implementations (and identified around 10 bugs during its\ndevelopment), it has the potential to be used much more systematically to\nthis effect.  One generic mechanism for testing diffs is "endpoint\ntesting", as follows:'),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"The tester writes a program that performs a sequence of filesystem\noperations (this can also be ",Object(r.b)("inlineCode",{parentName:"p"},"fsstress")," or the ",Object(r.b)("inlineCode",{parentName:"p"},"xfstests")," regression\ntest suite).")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"The filesystem operations are sent & received using regular tooling.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"A ",Object(r.b)("inlineCode",{parentName:"p"},"btrfs_diff")," program also consumes the send-streams, and constructs\na ",Object(r.b)("inlineCode",{parentName:"p"},"SubvolumeSet"),". It then traverses its ",Object(r.b)("inlineCode",{parentName:"p"},"Inode"),"s, and and issues\nsyscalls against the original filesystem, as well as the received\nfilesystem to verify all the data that it is aware of, including:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"file type, owner, mode, xattrs, link destinations, device #s"),Object(r.b)("li",{parentName:"ul"},"hardlinks -- use something like ",Object(r.b)("inlineCode",{parentName:"li"},"TraversalID")," to make the\nphysical inode numbers relevant to our in-memory tree."),Object(r.b)("li",{parentName:"ul"},"cloned extents -- akin to hardlinks, but use ",Object(r.b)("inlineCode",{parentName:"li"},"fiemap")," to obtain\nphysical block numbers.")))),Object(r.b)("p",{parentName:"li"},"Since ",Object(r.b)("inlineCode",{parentName:"p"},"btrfs_diff")," is focused on completeness of representation, this\napproach is better ad-hoc filesystem comparisons in that it can\nbe relied on to test all the data ",Object(r.b)("inlineCode",{parentName:"p"},"btrfs_diff")," tracks."),Object(r.b)("p",{parentName:"li"},"Additionally, ",Object(r.b)("inlineCode",{parentName:"p"},"btrfs_diff")," is in effect a parallel implementation of\n",Object(r.b)("inlineCode",{parentName:"p"},"btrfs receive")," together with an underlying filesystem, which provides a\nmeaningful sanity-check on userspace and on the kernel."),Object(r.b)("p",{parentName:"li"},"The end-game for such a kernel testing effort might even involve putting\nup the ",Object(r.b)("inlineCode",{parentName:"p"},"btrfs_diff")," library for inclusion into ",Object(r.b)("inlineCode",{parentName:"p"},"btrfs-progs")," (this might\nrequire a better name :).")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Add support for handling incremental sendstreams.  See the note in\n",Object(r.b)("inlineCode",{parentName:"p"},"sendstream_has_loop_device.py")," about adding the capability to construct a\n",Object(r.b)("inlineCode",{parentName:"p"},"Subvolume")," with special placeholder objects for the dependencies, which\nwe infer must be supplied by a parent subvolume.  This is relevant to the\nimage compiler, since it needs to be able to reason about the effects of\nrunning a sandboxed build step on the final image."))))}c.isMDXComponent=!0}}]);