(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{117:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),b=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=b(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),p=b(n),d=r,m=p["".concat(o,".").concat(d)]||p[d]||u[d]||i;return n?a.a.createElement(m,c(c({ref:t},s),{},{components:n})):a.a.createElement(m,c({ref:t},s))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var s=2;s<i;s++)o[s]=n[s];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},87:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return b}));var r=n(3),a=n(7),i=(n(0),n(117)),o={id:"extract",title:"Extract",generated:"@generated"},c={unversionedId:"api/genrule/extractor/extract",id:"api/genrule/extractor/extract",isDocsHomePage:!1,title:"Extract",description:"WARNING: you probably don't actually want this",source:"@site/docs/api/genrule/extractor/gen-extract.md",slug:"/api/genrule/extractor/extract",permalink:"/antlir/docs/api/genrule/extractor/extract",editUrl:"https://github.com/facebookincubator/antlir/edit/master/website/docs/api/genrule/extractor/gen-extract.md",version:"current"},l=[{value:"<code>extract</code>",id:"extract",children:[]},{value:"<code>source_layer</code>",id:"source_layer",children:[]}],s={toc:l};function b(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"WARNING: you probably don't actually want this\nextract.bzl exists for very stripped down environments (for example, building\nan initrd) that need a binary (most likely from an RPM) and its library\ndependencies. In almost every case ",Object(i.b)("em",{parentName:"p"},"other")," than building an initrd, you\neither want ",Object(i.b)("inlineCode",{parentName:"p"},"image.rpms_install")," or ",Object(i.b)("inlineCode",{parentName:"p"},"image.install_buck_runnable")),Object(i.b)("p",null,"If you're still here, ",Object(i.b)("inlineCode",{parentName:"p"},"extract.extract")," works by parsing the ELF information\nin the given binaries.\nIt then clones the binaries and any .so's they depend on from the source\nlayer into the destination layer. The actual clone is very unergonomic at\nthis point, and it is recommended to batch all binaries to be extracted into\na single call to ",Object(i.b)("inlineCode",{parentName:"p"},"extract.extract"),"."),Object(i.b)("p",null,"An important note: If you are using buck compiled binaries, you ",Object(i.b)("em",{parentName:"p"},"must"),"\nuse ",Object(i.b)("inlineCode",{parentName:"p"},"image.install(...)")," to insert them into your ",Object(i.b)("inlineCode",{parentName:"p"},"source")," layer and ",Object(i.b)("em",{parentName:"p"},"not"),"\n",Object(i.b)("inlineCode",{parentName:"p"},"image.install_buck_runnable(...)"),". This is the exact opposite of the\nsuggested usage in the rest of the API, and here's why:"),Object(i.b)("p",null,"If ",Object(i.b)("inlineCode",{parentName:"p"},"image.install_buck_runnable(...)")," is built in the case where\n",Object(i.b)("inlineCode",{parentName:"p"},"REPO_CFG.artifacts_require_repo == True"),", then what is ",Object(i.b)("em",{parentName:"p"},"actually"),"\ninstalled into the target ",Object(i.b)("inlineCode",{parentName:"p"},"image.layer")," is a shell script that exec's\nthe ",Object(i.b)("em",{parentName:"p"},"actual")," binary from the ",Object(i.b)("inlineCode",{parentName:"p"},"buck-out")," path contained somewhere in the\nrepo. Since this is a shell script, we can't easily do ELF extraction\nwithout doing some nasty file parsing, and right now we'd rather not\ndo that because it's possible that we can fix it correctly and ",Object(i.b)("inlineCode",{parentName:"p"},"image.install"),"\nis good enough."),Object(i.b)("p",null,"The caveat to using ",Object(i.b)("inlineCode",{parentName:"p"},"image.install")," is that the compiled binary must be\n",Object(i.b)("em",{parentName:"p"},"mostly")," static (meaning it only depends on the glibc it is compiled against)\n",Object(i.b)("strong",{parentName:"p"},"or")," it must ",Object(i.b)("em",{parentName:"p"},"not")," use relative references to shared objects that cannot\nbe resolved in the ",Object(i.b)("inlineCode",{parentName:"p"},"source"),". These restrictions, especially the last one, are\npretty difficult to reason about in advance of just trying to perform an\nextraction.  As a result, the best advice we can give at this point is to\nonly use ",Object(i.b)("inlineCode",{parentName:"p"},"rust_binary")," with the ",Object(i.b)("inlineCode",{parentName:"p"},'link_style = "static"')," option for any\nbinary target you want to use via the extractor."),Object(i.b)("p",null,"Future: Fixing the main problem with ",Object(i.b)("inlineCode",{parentName:"p"},"image.install_buck_runnable"),' would likely\ninvolve parsing the generated bash script and extracting the "real" path of the\nbinary.'),Object(i.b)("p",null,"We examined using symlinks to make parsing not required, but we can't\nreally use a symlink because many/most binaries that are built with buck using\nthis symlink farm structure rely on the fact that $0 resolves to a path within\n",Object(i.b)("inlineCode",{parentName:"p"},"buck-out"),".  So if we use a symlink it would break this assumption.  This\ndoesn't mean that parsing is the only option, but the most obvious alternative\n(symlinks) won't work with the current way buck builds these binaries."),Object(i.b)("h1",{id:"api"},"API"),Object(i.b)("h2",{id:"extract"},Object(i.b)("inlineCode",{parentName:"h2"},"extract")),Object(i.b)("p",null,"Prototype: ",Object(i.b)("inlineCode",{parentName:"p"},"extract(source, binaries, dest)")),Object(i.b)("p",null,"No docstring available."),Object(i.b)("h2",{id:"source_layer"},Object(i.b)("inlineCode",{parentName:"h2"},"source_layer")),Object(i.b)("p",null,"Prototype: ",Object(i.b)("inlineCode",{parentName:"p"},"source_layer(name, **kwargs)")),Object(i.b)("p",null,"No docstring available."))}b.isMDXComponent=!0}}]);